{
  "always_run_in_app" : false,
  "icon" : {
    "color" : "deep-gray",
    "glyph" : "book-open"
  },
  "name" : "Read Ebook",
  "script" : "\/\/ Made by @memalign - 1\/1\/19\n\/\/ Copyright 2019\n\n\/\/ First, convert ebook to text using http:\/\/www.convertfiles.com\/convert\/ebook\/EPUB-to-TXT.html\n\/\/ Then, using Files, save the result to Scriptable's space\n\n\nlet fm = FileManager.iCloud()\n\nlet fullBookPath = fm.documentsDirectory() + \"\/thinking fast and slow - daniel kahneman.txt\"\n\n\n\/\/ File format:\n\/\/ currentLineNumber\\n   - integer, offset into full book\nlet inProgressPath = fullBookPath + \".inProgress.txt\"\n\n\nif (!fm.fileExists(inProgressPath)) {\n  console.log(\"Creating in progress copy\")\n  fm.writeString(inProgressPath, \"0\\n\")\n}\n\n\nlet lines = fm.readString(fullBookPath).split(\"\\n\")\nlet lineOffset = 0\n\nlet fullBookLineCount = lines.length\n\nconst DEFAULT_APPROX_WORDS_PER_CHUNK = 600\n\nlet wordsPerChunk = DEFAULT_APPROX_WORDS_PER_CHUNK\n\nlet handsFreeMode = false\n\ndo {\n\n  let progress = fm.readString(inProgressPath)\n  if (!progress) {\n    break\n  } else {\n    lineOffset = parseInt((progress.split(\"\\n\"))[0])\n  }\n  \n  \/\/ Pick enough lines to have enough words\n  \n  let lineCount = findNumLinesToAchieveWordCount(lines, lineOffset, wordsPerChunk)\n  \n  console.log(\"Showing chunk of \" + lineCount + \" lines with \" + (lines.length-lineCount) + \" remaining\")\n  \n  let chunkStr = stringForNumLines(lines, lineOffset, lineCount)\n  \n  \/\/ console.log(chunkStr)\n  \n  let action = \"read\"\n\n\n  if (handsFreeMode) {\n    let voiceCommand = await getDictatedText()\n    \n    let shouldStop = voiceCommand.match(\/stop\/i)\n    if (shouldStop) {\n      action = \"stop\"\n    }\n  } else {\n    let actionAndWPC = await showWebViewWithText(chunkStr, lineOffset, fullBookLineCount, wordsPerChunk)\n    \n    action = actionAndWPC[0]\n    wordsPerChunk = actionAndWPC[1]\n  }\n  \n  if (action === \"stop\") {\n    break\n  }\n  \n  if (action === \"start over\") {\n    let alert = new Alert()\n    alert.title = \"Start Over\"\n    alert.message = \"Are you sure you want to forget all progress? This cannot be undone.\"\n    alert.addDestructiveAction(\"Start Over\")\n    alert.addAction(\"Cancel\")\n    if (await alert.present() == 0) {\n      console.log(\"Starting over!\")\n      fm.remove(inProgressPath)\n    }\n    \n    break\n  }\n  \n  if (action === \"hands free\") {\n    action = \"read\"\n    handsFreeMode = true\n  }\n  \n  if (action === \"read\") {\n    await speakText(chunkStr)\n  }\n  \n  if (action === \"previous\") {\n    lineOffset -= findNumLinesToGoBack(lines, lineOffset, wordsPerChunk)\n  \n    lineCount = 0\n  }\n  \n  updateInProgressFile(lineOffset+lineCount, fullBookLineCount, inProgressPath)\n\n} while (true)\n\n\n\nfunction updateInProgressFile(newLineOffset, fullBookLineCount, inProgressPath) {\n  if (newLineOffset >= fullBookLineCount) {\n    console.log(\"No more lines remain!\")\n    fm.remove(inProgressPath)\n    return\n  }\n  \n  \n  \/\/ Write to a temp file\n  let tempFile = fm.documentsDirectory() + \"\/temp-book.txt\"\n  \n  fm.writeString(tempFile, newLineOffset+\"\\n\")\n  \n  console.log(\"Replacing \" + inProgressPath)\n  \n  \/\/ Move the temp file to final path\n  fm.remove(inProgressPath) \/\/ seems to be required since move errors if the destination file exists (contradicting the docs)\n  fm.move(tempFile, inProgressPath)\n}\n\nasync function showWebViewWithText(text, lineOffset, totalLineCount, wordsPerChunk) {\n  let webView = new WebView()\n  \n  let html = \"<html>\"\n  html += \"<body>\"\n  \n  html += `\n  <script>\n  document.body.style.zoom = 4.0\n  <\/script>\n  `\n  \n  html += \"<center>\"\n  \n  html += \"<table>\"\n  \n  html += \"<tr>\"\n  html += \"<td><input type='button' value='stop' onclick='setAction(\\\"stop\\\")'><\/td>\"\n  html += \"<td><input type='button' value='skip' onclick='setAction(\\\"skip\\\")'><\/td>\"\n  html += \"<td><input type='button' value='read' onclick='setAction(\\\"read\\\")'><\/td>\"\n  html += \"<td><input type='button' value='hands free' onclick='setAction(\\\"hands free\\\")'><\/td>\"\n  html += \"<\/tr>\"\n  \n  html += \"<\/table>\"\n  \n  \n  html += \"<table>\"\n  html += \"<tr>\"\n  \n  html += \"<td><input type='text' size='5' style='text-align:center;' id='desiredAction' value='read'><\/td>\"\n  html += \"<td><input type='text' size='5' style='text-align:center;' id='wordsPerChunk' value='\"+wordsPerChunk+\"'> words<\/td>\"\n  \n  html += \"<\/tr>\"\n  html += \"<\/table>\"\n  \n  html += \"<br \/>\"\n  \n  let linesRead = lineOffset\n  html += \"Progress: \" + linesRead + \"\/\" + totalLineCount + \" = \" + (100*linesRead\/totalLineCount).toFixed(1) + \"%\"\n  \n  html += \"<\/center>\"\n  \n  html += \"<table>\"\n  \n  let lines = text.split(\"\\n\")\n  let count = 0\n  for (line of lines) {\n    html += \"<tr>\"\n\n    html += \"<td>\"\n    html += htmlEncode(line)\n    html += \"<\/td>\"\n    \n    html += \"<\/tr>\"\n    \n    count++\n  }\n  \n  html += \"<\/table>\"\n  \n  html += \"<br \/><br \/>\"\n  \n  html += \"<center>\"\n  html += \"<table>\"\n  \n  html += \"<tr>\"\n  html += \"<td><input type='button' value='previous' onclick='setAction(\\\"previous\\\")'><\/td>\"\n  html += \"<td><input type='button' value='start over' onclick='setAction(\\\"start over\\\")'><\/td>\"\n  html += \"<\/tr>\"\n  \n  html += \"<\/table>\"\n  html += \"<\/center>\"\n  \n  \n  html += `\n  <script>\n  \n  function setAction(str) {\n    document.getElementById(\"desiredAction\").value = str\n  }\n  \n  function getDesiredAction() {\n    let actionInput = document.getElementById(\"desiredAction\")\n    \n    return actionInput.value\n  }\n  \n  function getWordsPerChunk() {\n    let wpcInput = document.getElementById(\"wordsPerChunk\")\n    \n    return wpcInput.value\n  }\n  \n  <\/script>\n  `\n  \n  html += \"<\/body><\/html>\"\n  \n  await webView.loadHTML(html)\n  await webView.present()\n  \n  let selectedAction = await webView.evaluateJavaScript(\"getDesiredAction()\")\n  console.log(\"action:\\n\" + selectedAction)\n  \n  let wpc = await webView.evaluateJavaScript(\"getWordsPerChunk()\")\n  console.log(\"wpc: \" + wpc)\n  \n  return [selectedAction, wpc]\n}\n\n\n\nfunction stringForNumLines(lines, lineOffset, numLines) {\n  let str = \"\"\n  \n  for (let i = 0; i < numLines; i++) {\n    str += \"\\n\" + lines[i+lineOffset];\n  }\n  \n  return str\n}\n\n\nfunction findNumLinesToAchieveWordCount(lines, lineOffset, desiredWordCount) {\n  let lineCount = 0\n  \n  let accumWC = 0\n  \n  for (let i = lineOffset; i < lines.length; i++) {\n    \n    let line = lines[i]\n    let lineWC = line.split(\" \").length\n    \n    \/\/ Don't far exceed word count\n    if (i > 0 && lineWC > 2*desiredWordCount) {\n      break\n    }\n    \n    lineCount++\n    accumWC += lineWC\n    \n    if (accumWC >= desiredWordCount) {\n      break\n    }\n  }\n  \n  return lineCount\n}\n\n\nfunction findNumLinesToGoBack(lines, lineOffset, wordsPerChunk) {\n  let numToGoBack = 0\n  \n  for (numToGoBack = 0; numToGoBack <= lineOffset; numToGoBack++) {\n    let numLinesWeWouldPick = findNumLinesToAchieveWordCount(lines, lineOffset-numToGoBack, wordsPerChunk)\n    \n    \/\/ if our offset were lineOffset-numToGoBack\n    \/\/ we would show numLinesWeWouldPick lines\n    \n    \/\/ if (lineOffset-numToGoBack) + numLinesWeWouldPick is equal to our current offset then that's the previous offset we had\n    \/\/ if that sum is less than our current offset then it would be going back too far\n    \n    let testOffset = (lineOffset-numToGoBack) + numLinesWeWouldPick\n    \n    if (testOffset <= lineOffset) {\n      break\n    }\n  }\n  \n  console.log(\"Going back by \" + numToGoBack + \" lines\")\n  \n  return numToGoBack\n}\n\n\n\/\/ I call over to a shortcut because the Speech support in Scriptable doesn't let me configure the speaking speed\n\/\/ https:\/\/www.icloud.com\/shortcuts\/da4c0a13f3a4435a8daf5bb4eb6b8c12\nasync function speakText(text) {\n  let callbackURL = new CallbackURL(\"shortcuts:\/\/x-callback-url\/run-shortcut\")\n  callbackURL.addParameter(\"name\", \"SpeakText\")\n  callbackURL.addParameter(\"input\", \"text\")\n  callbackURL.addParameter(\"text\", text)\n  console.log(\"callbackurl: \" + callbackURL.getURL())\n  \n  let result = await callbackURL.open()\n  console.log(\"speakText result: \" + result)\n}\n\n\/\/ I call over to a shortcut because the Dictation support in Scriptable requires touch interaction\n\/\/ https:\/\/www.icloud.com\/shortcuts\/daa622bd046f484caa9a133b9deed342\nasync function getDictatedText() {\n  let callbackURL = new CallbackURL(\"shortcuts:\/\/x-callback-url\/run-shortcut\")\n  callbackURL.addParameter(\"name\", \"Dictate\")\n  \n  console.log(\"callbackurl: \" + callbackURL.getURL())\n  \n  let result = await callbackURL.open()\n  \n  console.log(\"dictated text: \" + result.result)\n  \n  return result.result\n}\n\n\n\/\/ HTML encoding utilities\n\/\/ Main logic from https:\/\/ourcodeworld.com\/articles\/read\/188\/encode-and-decode-html-entities-using-pure-javascript\n\nfunction htmlEncode(str) {\n  var buf = [];\n\t\t\t\n  for (var i=str.length-1;i>=0;i--) {\n    buf.unshift(['&#', str[i].charCodeAt(), ';'].join(''));\n  }\n\t\t\t\n  return buf.join('');\n}\n\nfunction htmlDecode(str) {\n  return str.replace(\/&#(\\d+);\/g, function(match, dec) {\n    return String.fromCharCode(dec);\n  });\n}",
  "share_sheet_inputs" : [

  ]
}